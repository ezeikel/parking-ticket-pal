generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
}

model User {
  id            String     @id @default(cuid())
  email         String     @unique
  name          String?
  emailVerified DateTime?
  image         String?
  title         UserTitle?
  phoneNumber   String? // TODO: Rename to mobileNumber since we only accept UK mobile numbers for SMS reminders
  address       Json?
  // example address:
  //  const address = {
  //  line1: "123 Main St",
  //  line2: "Apt 4B",
  //  city: "London",
  //  county: "Greater London",
  //  postcode: "SW1A 1AA",
  //  country: "United Kingdom",
  //  coordinates: {
  //  latitude: 51.5074,
  //  longitude: -0.1278
  //  }

  role                  UserRole      @default(USER)
  stripeCustomerId      String? // set after Stripe customer creation
  revenueCatCustomerId  String? // set after RevenueCat identification
  createdAt             DateTime      @default(now())
  updatedAt             DateTime      @updatedAt
  signatureUrl          String?
  subscription          Subscription?
  vehicles              Vehicle[]
  accounts              Account[]
  sessions              Session[]

  @@map("users")
}

model Vehicle {
  id                 String        @id @default(cuid())
  userId             String
  make               String
  model              String
  bodyType           String
  fuelType           String
  year               Int
  color              String
  registrationNumber String        @unique
  notes              String?
  active             Boolean       @default(true)
  createdAt          DateTime      @default(now())
  updatedAt          DateTime      @updatedAt
  tickets            Ticket[]
  user               User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  verification       Verification?

  @@map("vehicles")
}

model Ticket {
  id                String @id @default(cuid())
  pcnNumber         String @unique
  contraventionCode String
  location          Json
  // example address:
  //  const address = {
  //  line1: "123 Main St",
  //  line2: "Apt 4B",
  //  city: "London",
  //  county: "Greater London",
  //  postcode: "SW1A 1AA",
  //  country: "United Kingdom",
  //  coordinates: {
  //  latitude: 51.5074,
  //  longitude: -0.1278
  //  }

  extractedText   String
  issuedAt        DateTime
  contraventionAt DateTime
  observedAt      DateTime?
  status          TicketStatus     @default(ISSUED_DISCOUNT_PERIOD)
  type            TicketType
  initialAmount   Int
  statusUpdatedAt DateTime? // When status was last updated
  statusUpdatedBy String? // "SYSTEM" | "USER" | "LETTER_PARSER"
  issuer          String
  issuerType      IssuerType
  verified        Boolean          @default(false)
  notes           String?
  tier            TicketTier       @default(FREE)
  vehicleId       String
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  forms           Form[]
  letters         Letter[]
  media           Media[]
  prediction      Prediction?
  reminders       Reminder[]
  amountIncreases AmountIncrease[]
  challenges      Challenge[]
  vehicle         Vehicle          @relation(fields: [vehicleId], references: [id], onDelete: Cascade)
  verification    Verification?

  @@map("tickets")
}

model Media {
  id           String        @id @default(cuid())
  url          String
  description  String?
  type         MediaType
  source       MediaSource
  evidenceType EvidenceType? // for user uploaded evidence categorisation
  ticketId     String?
  letterId     String?
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  letter       Letter?       @relation(fields: [letterId], references: [id])
  ticket       Ticket?       @relation(fields: [ticketId], references: [id], onDelete: Cascade)

  @@map("media")
}

model Letter {
  id            String     @id @default(cuid())
  type          LetterType
  ticketId      String
  extractedText String? // extracted text from uploaded image
  summary       String // user summary of letter or generated by image analysis
  sentAt        DateTime
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt

  ticket         Ticket          @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  media          Media[]
  amountIncrease AmountIncrease?

  @@map("letters")
}

model Subscription {
  id                       String             @id @default(cuid())
  userId                   String             @unique
  user                     User               @relation(fields: [userId], references: [id])
  stripeSubscriptionId     String?            @unique // set after Stripe subscription creation
  revenueCatSubscriptionId String?            @unique // set after RevenueCat subscription creation
  type                     SubscriptionType   @default(STANDARD)
  source                   SubscriptionSource @default(STRIPE)
  createdAt                DateTime           @default(now())
  updatedAt                DateTime           @updatedAt

  @@map("subscriptions")
}

model Reminder {
  id               String            @id @default(cuid())
  type             ReminderType
  notificationType NotificationType? @default(EMAIL)
  ticketId         String
  sendAt           DateTime
  sentAt           DateTime?
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt
  ticket           Ticket            @relation(fields: [ticketId], references: [id], onDelete: Cascade)

  @@index([ticketId, sendAt])
  @@map("reminders")
}

model Form {
  id        String    @id @default(cuid())
  ticketId  String
  formType  FormType
  fileName  String
  fileUrl   String
  dueAt     DateTime?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  ticket    Ticket    @relation(fields: [ticketId], references: [id], onDelete: Cascade)

  @@map("forms")
}

model Prediction {
  id            String         @id @default(cuid())
  ticketId      String         @unique
  type          PredictionType @default(CHALLENGE_SUCCESS)
  percentage    Int            @default(50)
  numberOfCases Int            @default(0)
  confidence    Float          @default(0.8)
  lastUpdated   DateTime       @default(now())
  metadata      Json?
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  ticket        Ticket         @relation(fields: [ticketId], references: [id], onDelete: Cascade)

  @@map("predictions")
}

model AmountIncrease {
  id          String                   @id @default(cuid())
  ticketId    String
  amount      Int // full amount due after this increase
  reason      String? // optional explanation (e.g., "Charge Certificate", "Manual override")
  sourceType  AmountIncreaseSourceType // LETTER, MANUAL_UPDATE, SYSTEM
  sourceId    String? // Optional ID reference (e.g. letter ID if sourceType is LETTER)
  effectiveAt DateTime
  createdAt   DateTime                 @default(now())
  updatedAt   DateTime                 @updatedAt

  ticket   Ticket  @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  letter   Letter? @relation(fields: [letterId], references: [id])
  letterId String? @unique // Makes this a one-to-one with Letter

  @@index([ticketId, effectiveAt])
  @@map("amount_increases")
}

model Verification {
  id         String             @id @default(cuid())
  type       VerificationType
  status     VerificationStatus @default(UNVERIFIED)
  verifiedAt DateTime?
  metadata   Json?
  vehicleId  String?            @unique
  ticketId   String?            @unique
  createdAt  DateTime           @default(now())
  updatedAt  DateTime           @updatedAt
  vehicle    Vehicle?           @relation(fields: [vehicleId], references: [id], onDelete: Cascade)
  ticket     Ticket?            @relation(fields: [ticketId], references: [id], onDelete: Cascade)

  @@unique([type, vehicleId, ticketId])
  @@map("verifications")
}

enum ChallengeResponseStatus {
  PENDING
  ACCEPTED
  REJECTED
  UNDER_REVIEW
  CANCELLED
  OTHER
}

model Challenge {
  id           String          @id @default(cuid())
  ticketId     String
  type         ChallengeType
  reason       String
  customReason String?
  status       ChallengeStatus @default(PENDING)
  metadata     Json? // store additional data like download URLs, error messages, etc.

  // enhanced fields for better tracking
  submittedAt        DateTime? // when the challenge was actually submitted (for auto-challenges)
  responseReceivedAt DateTime? // when response was received from authority
  responseStatus     ChallengeResponseStatus? // status of authority response
  responseDetails    Json? // store response details, appeal rights, etc.

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  ticket Ticket @relation(fields: [ticketId], references: [id], onDelete: Cascade)

  @@index([ticketId, createdAt])
  @@map("challenges")
}

// Auth.js models

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

enum TicketType {
  PARKING_CHARGE_NOTICE
  PENALTY_CHARGE_NOTICE
}

enum LetterType {
  INITIAL_NOTICE
  NOTICE_TO_OWNER
  CHARGE_CERTIFICATE
  ORDER_FOR_RECOVERY
  CCJ_NOTICE
  FINAL_DEMAND
  BAILIFF_NOTICE
  APPEAL_RESPONSE
  GENERIC
  CHALLENGE_LETTER
}

enum MediaType {
  IMAGE
  VIDEO
  AUDIO
}

enum TicketStatus {
  // Common initial stages
  ISSUED_DISCOUNT_PERIOD
  ISSUED_FULL_CHARGE

  // Council / TfL (public) flow
  NOTICE_TO_OWNER
  FORMAL_REPRESENTATION
  NOTICE_OF_REJECTION
  REPRESENTATION_ACCEPTED
  CHARGE_CERTIFICATE
  ORDER_FOR_RECOVERY
  TEC_OUT_OF_TIME_APPLICATION
  PE2_PE3_APPLICATION
  APPEAL_TO_TRIBUNAL
  ENFORCEMENT_BAILIFF_STAGE

  // Private parking flow
  NOTICE_TO_KEEPER
  APPEAL_SUBMITTED_TO_OPERATOR
  APPEAL_REJECTED_BY_OPERATOR
  POPLA_APPEAL
  IAS_APPEAL
  APPEAL_UPHELD
  APPEAL_REJECTED
  DEBT_COLLECTION
  COURT_PROCEEDINGS
  CCJ_ISSUED

  // Final stage if user decides to pay
  PAID

  // Cancelled tickets
  CANCELLED
}

enum IssuerType {
  COUNCIL
  TFL
  PRIVATE_COMPANY
}

enum SubscriptionType {
  STANDARD
  PREMIUM
}

enum SubscriptionSource {
  STRIPE
  REVENUECAT
}

enum ReminderType {
  DISCOUNT_PERIOD
  FULL_CHARGE
  APPEAL_DEADLINE
  NOTICE_TO_OWNER_RESPONSE
  CHARGE_CERTIFICATE_RESPONSE
  FORM_DEADLINE
  OUT_OF_TIME_NOTICE
}

enum NotificationType {
  EMAIL
  SMS
}

enum TransactionType {
  PURCHASE
  CONSUME
}

enum ProductType {
  PAY_PER_TICKET
  PRO_MONTHLY
  PRO_ANNUAL
}

enum MediaSource {
  ISSUER
  TICKET
  LETTER
  USER
  EVIDENCE
}

enum FormType {
  PE2
  PE3
  TE7
  TE9
}

enum PredictionType {
  CHALLENGE_SUCCESS
}

enum VerificationType {
  VEHICLE
  TICKET
}

enum VerificationStatus {
  VERIFIED
  UNVERIFIED
  FAILED
}

enum AmountIncreaseSourceType {
  LETTER
  MANUAL_UPDATE
  SYSTEM
}

enum ChallengeType {
  LETTER
  AUTO_CHALLENGE
}

enum ChallengeStatus {
  PENDING
  IN_PROGRESS
  SUCCESS
  ERROR
  TIMEOUT
  CANCELLED
}

enum TicketTier {
  FREE
  STANDARD
  PREMIUM
}

enum EvidenceType {
  PHOTO_OF_SIGNAGE
  PHOTO_OF_VEHICLE
  WITNESS_STATEMENT
  PAYMENT_PROOF
  CORRESPONDENCE
  OTHER
}

enum UserRole {
  USER
  ADMIN
}

enum UserTitle {
  MR
  MRS
  MS
  DR
  PROF
  SIR
  LADY
}

// London Tribunal Cases - scraped historical data for ML predictions
model LondonTribunalCase {
  id                    String          @id @default(cuid())
  caseReference         String          @unique
  declarant             String?
  authority             String
  vrm                   String?
  pcn                   String?
  contraventionDate     DateTime?
  contraventionTime     String?
  contraventionLocation String?
  penaltyAmount         Decimal?        @db.Decimal(10, 2)
  contravention         String?
  referralDate          DateTime?
  decisionDate          DateTime?
  adjudicator           String?
  appealDecision        AppealDecision
  direction             String?
  reasons               String          @db.Text
  scrapedAt             DateTime        @default(now())
  updatedAt             DateTime        @updatedAt

  @@index([authority, contravention])
  @@index([appealDecision])
  @@index([contraventionDate])
  @@index([caseReference])
  @@map("london_tribunal_cases")
}

enum AppealDecision {
  ALLOWED
  REFUSED
  PARTIALLY_ALLOWED
  WITHDRAWN
  STRUCK_OUT
}
